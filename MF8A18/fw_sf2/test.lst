      //      // Copyright 2018 MicroFPGA UG      // Apache 2.0 License      //            #file 2      #line 1      // Microcode Mnemonics for RISC-V             var ZERO: byte @R0;      var FF: byte @R1;            var ECAUSE: byte @R9;      var PC: word @R10;      var oldPC: word @R12;            // Instruction word      var I0: byte @R16;      var I1: byte @R17;      var I2: byte @R18;      var I3: byte @R19;            // Destination work area      var RD0: byte @R20;      var RD1: byte @R21;      var RD2: byte @R22;      var RD3: byte @R23;            var RS2_0: byte @R24;      var RS2_1: byte @R25;      var RS2_2: byte @R26;      var RS2_3: byte @R27;            var TEMP: byte @R28;      // 29 is WREG      var Z: word @W30;      var Zlo: byte @R30;      var Zhi: byte @R31;                  var RS1_0: byte @R12;      var RS1_1: byte @R13;      var RS1_2: byte @R14;      var RS1_3: byte @R15;                        const RRH = $F1;      const CRH = $F2;                                          	            #file 1      #line 7            //#include brd_mdp.inc      #file 3      #line 1            const UART_BAUDCONST = 143; // 115200 @50MHz            #file 1      #line 10      //#include brd_s7m.inc            //      // Start here      //      	WREG := 0; ZERO := WREG; // simulator friendly version, can save 2 bytes in FPGA !0000:E0F0 LDI R31,0x000001:2E0F MOV R0,R31      	WREG := $FF0002:EFFF LDI R31,0xFF      	FF   := WREG;0003:2E1F MOV R1,R31            //#include spi_boot.inc            //#include raminit.inc	            	PC.lo := ZERO;0004:2CA0 MOV R10,R0      	PC.hi := ZERO;0005:2CB0 MOV R11,R0            //======================================      //      // Main Loop      //	            	goto MainStart0006:C027 RJMP 0x002E      MISALIGN_LD:      	WREG := 40007:E0F4 LDI R31,0x04      	goto misaling_ldst0008:C001 RJMP 0x000A      MISALIGN_ST:      	WREG := 60009:E0F6 LDI R31,0x06      misaling_ldst:      	oldPC := PC000A:2CCA MOV R12,R10000B:2CDB MOV R13,R11      	PC.lo := Z.lo 000C:2EAE MOV R10,R30      	PC.hi := Z.hi000D:2EBF MOV R11,R31      	goto mtvec_mtval000E:C014 RJMP 0x0023            Store_0:      	RD0 := 0;000F:E040 LDI R20,0x00      Store_RD_BYTE:      	RD1 := 0;0010:E050 LDI R21,0x00      Store_RD_WORD:      	RD2 := 0;0011:E060 LDI R22,0x00      	RD3 := 0;0012:E070 LDI R23,0x00            Store_RD:            // xxxx_xxxx xxxx_xxxx xxxx_4321 0xxx_xxxx      // x432 10xx      //  	Z.lo := I1      //	swap Z.lo      //	lsr Z.lo      //	and Z.lo, $78      //	if not I0.7 then skip; Z.lo := Z.lo or $04;              	Z.lo := I10013:2FE1 MOV R30,R17      	swap Z.lo0014:95E2 SWAP R30      	//lsr Z.lo      	and Z.lo, $F00015:7FE0 ANDI R30,0xF0      	if not I0.7 then skip; Z.lo := Z.lo or $08;0016:FD07 SBRC R16,70017:60E8 ORI R30,0x08                  	// rd = 0? If so do not store it!      	if Z.lo = $00 then MainLoop0018:23EE AND R30,R300019:F029 BREQ 0x001F      	// Store RD to r1..r31      	Z.Hi := RRH; // Register save area001A:EFF1 LDI R31,0xF1      	RAM[Z] := RD0; 001B:8340 ST Z,R20      	RAM[Z+1] := RD1;001C:8351 ST Z+1,R21      	RAM[Z+2] := RD2;001D:8362 ST Z+2,R22      	RAM[Z+3] := RD3; 001E:8373 ST Z+3,R23            	repeat      MainLoop:      //      // Fetch new instruction word into I0..I3      //              WREG := PC.lo001F:2DFA MOV R31,R10      	if not WREG.1 then NextPC0020:FFF1 SBRS R31,10021:C009 RJMP 0x002B      // Misaligned jump!      	WREG := 0; // Misaligned jump0022:E0F0 LDI R31,0x00      mtvec_mtval:      	Z.hi  := CRH0023:EFF2 LDI R31,0xF2      	// store mtval      	Z.lo := $300024:E3E0 LDI R30,0x30      	RAM[Z] := PC.lo; //0025:82A0 ST Z,R10      	RAM[Z+1] := PC.hi0026:82B1 ST Z+1,R11      mtvec_mepc:      	// store mepc      	Z.lo := $100027:E1E0 LDI R30,0x10      	RAM[Z] := oldPC.lo; //0028:82C0 ST Z,R12      	RAM[Z+1] := oldPC.hi0029:82D1 ST Z+1,R13      mtvec_ecause:      	goto go_mtvec_ecause002A:C0CF RJMP 0x00FA      //      NextPC:              //PC := PC+4;              PC.lo := PC.lo+4;002B:E0F4 LDI R31,0x04002C:0EAF ADD R10,R31      	ADC PC.hi, ZERO002D:1CB0 ADC R11,R0            MainStart:      //      // Thread switching should appear here for hardware multithreaded support      //            	oldPC := PC002E:2CCA MOV R12,R10002F:2CDB MOV R13,R11      	Z := PC;0030:2DEA MOV R30,R100031:2DFB MOV R31,R11                        	I0 := RAM[Z];0032:8100 LD R16,Z       	I1 := RAM[Z+1];0033:8111 LD R17,Z+1      	I2 := RAM[Z+2]; 0034:8122 LD R18,Z+2      	I3 := RAM[Z+3];0035:8133 LD R19,Z+3            //      // Start instruction decoding and emulation      //             if I0.2 then goto I_XX_XX10036:FD02 SBRC R16,20037:C172 RJMP 0x01AA      //      // need load rs1      //            // xxxx_xxxx xxxx_xxxx xxxx_4321 0xxx_xxxx      // x432 10xx            LD_rs1:      //        Z.lo := I2      //	swap Z.lo      //	lsr Z.lo      //	Z.lo := Z.lo and $78      //	if not I1.7 then skip; Z.lo := Z.lo or $04;                    Z.lo := I20038:2FE2 MOV R30,R18      	swap Z.lo0039:95E2 SWAP R30      	//lsr Z.lo      	Z.lo := Z.lo and $F0003A:7FE0 ANDI R30,0xF0      	if not I1.7 then skip; Z.lo := Z.lo or $08;003B:FD17 SBRC R17,7003C:60E8 ORI R30,0x08            //      	Z.Hi := RRH; // Register save area003D:EFF1 LDI R31,0xF1      	RS1_0 := RAM[Z]; 003E:80C0 LD R12,Z       	RS1_1 := RAM[Z+1]; 003F:80D1 LD R13,Z+1      	RS1_2 := RAM[Z+2];0040:80E2 LD R14,Z+2      	RS1_3 := RAM[Z+3]; 0041:80F3 LD R15,Z+3                    if I0.5 then goto I_X1_XX00042:FD05 SBRC R16,50043:C097 RJMP 0x00DB      //      I_0X_XX0:      I_XX_XX0:      I_IMMED:      // Get immed 11:0 and sign extend	      	RD3 := $FF; // 0044:EF7F LDI R23,0xFF      	RD2 := $FF; // 0045:EF6F LDI R22,0xFF      	RD0 := I2; SWAP RD0; RD0 := RD0 and $0F;0046:2F42 MOV R20,R180047:9542 SWAP R200048:704F ANDI R20,0x0F      	SWAP I3;0049:9532 SWAP R19      	RD1 := I3;          RD1 := RD1 or $F0;004A:2F53 MOV R21,R19004B:6F50 ORI R21,0xF0      	I3 := I3 and $F0;   RD0 := RD0 or I3;004C:7F30 ANDI R19,0xF0004D:2B43 OR  R20,R19      	if RD1.3 then goto imm12_p004E:FD53 SBRC R21,3004F:C003 RJMP 0x0053      	RD1 := RD1 and $0F;0050:705F ANDI R21,0x0F      	RD2 := 0;0051:E060 LDI R22,0x00      	RD3 := 0; 0052:E070 LDI R23,0x00      imm12_p:        // 12 bit immed in RD	              if not I0.4 then goto I_00_0X1 // JALR >>0053:FF04 SBRS R16,40054:C054 RJMP 0x00A9            // IMM ALU              if I1.6 then goto LOGIC0055:FD16 SBRC R17,60056:C009 RJMP 0x0060      // 0XX              if I1.5 then goto DO_SLT0057:FD15 SBRC R17,50058:C043 RJMP 0x009C      // 00X              if I1.4 then goto DO_SLLI0059:FD14 SBRC R17,4005A:C01B RJMP 0x0076      // 000      // ADDI      // 32 bit ADD      Do_ADDI:              RD0 := RD0 + RS1_0005B:0D4C ADD R20,R12              ADC RD1, RS1_1005C:1D5D ADC R21,R13              ADC RD2, RS1_2005D:1D6E ADC R22,R14              ADC RD3, RS1_3005E:1D7F ADC R23,R15      	goto Store_RD005F:CFB3 RJMP 0x0013            LOGIC:              if I1.5 then goto OR_AND0060:FD15 SBRC R17,50061:C007 RJMP 0x0069              if I1.4 then goto Do_SR0062:FD14 SBRC R17,40063:C026 RJMP 0x008A      Do_XOR:              RD0 := RD0 xor RS1_00064:254C EOR R20,R12              RD1 := RD1 xor RS1_10065:255D EOR R21,R13              RD2 := RD2 xor RS1_20066:256E EOR R22,R14              RD3 := RD3 xor RS1_30067:257F EOR R23,R15      	goto Store_RD0068:CFAA RJMP 0x0013            OR_AND:              if I1.4 then goto DO_AND0069:FD14 SBRC R17,4006A:C005 RJMP 0x0070      Do_OR:              RD0 := RD0 or RS1_0006B:294C OR  R20,R12              RD1 := RD1 or RS1_1006C:295D OR  R21,R13              RD2 := RD2 or RS1_2006D:296E OR  R22,R14              RD3 := RD3 or RS1_3006E:297F OR  R23,R15      	goto Store_RD006F:CFA3 RJMP 0x0013      Do_AND:              RD0 := RD0 and RS1_00070:214C AND R20,R12              RD1 := RD1 and RS1_10071:215D AND R21,R13              RD2 := RD2 and RS1_20072:216E AND R22,R14              RD3 := RD3 and RS1_30073:217F AND R23,R15      	goto Store_RD0074:CF9E RJMP 0x0013            Do_SLL:      	RD0 := RS2_00075:2F48 MOV R20,R24      //	Goto Do_SLLI	      DO_SLLI:      	RD0 := RD0 and $1F;0076:714F ANDI R20,0x1F      asm      	breq Store_RS10077:F031 BREQ 0x007E      end      	repeat      		ADD RS1_0, RS1_00078:0CCC ADD R12,R12      		ADC RS1_1, RS1_10079:1CDD ADC R13,R13      		ADC RS1_2, RS1_2007A:1CEE ADC R14,R14      		ADC RS1_3, RS1_3007B:1CFF ADC R15,R15            		ADD RD0,FF007C:0D41 ADD R20,R1      	until FLAGS.1007D:F7D1 BRNE 0x0078      //	until --RD0;            Store_RS1:      	RD0 := RS1_0;007E:2D4C MOV R20,R12      	RD1 := RS1_1;007F:2D5D MOV R21,R13      	RD2 := RS1_2;0080:2D6E MOV R22,R14      	RD3 := RS1_3;0081:2D7F MOV R23,R15      	goto Store_RD0082:CF90 RJMP 0x0013            Do_XOR_AND:      	if I1.5 then goto OR_AND // bit 0083:FD15 SBRC R17,50084:CFE4 RJMP 0x0069      	if not I1.4 then goto Do_XOR // bit 0085:FF14 SBRS R17,40086:CFDD RJMP 0x0064      // SRL SRA      	RD0 := RS2_00087:2F48 MOV R20,R24      	RD1 := I30088:2F53 MOV R21,R19      	swap RD10089:9552 SWAP R21      //	goto Do_SR            //      // SRLI, SRAI      //      Do_SR:      	RD0 := RD0 and $1F;008A:714F ANDI R20,0x1F      asm      	breq Store_RS1008B:F391 BREQ 0x007E      end            // SRLI/SRAI?      	// I3.6 > RD1.3 !      	if not RD1.2 then goto DO_SRLI008C:FF52 SBRS R21,2008D:C007 RJMP 0x0095      // SRAI      	repeat      		ASR RS1_3008E:94F5 ASR R15      		ROR RS1_2008F:94E7 ROR R14      		ROR RS1_10090:94D7 ROR R13      		ROR RS1_00091:94C7 ROR R12      		ADD RD0,FF0092:0D41 ADD R20,R1      	until FLAGS.10093:F7D1 BRNE 0x008E      //	until --RD0;            	goto Store_RS10094:CFE9 RJMP 0x007E            //      Do_SRLI:      	repeat      		LSR RS1_30095:94F6 LSR R15      		ROR RS1_20096:94E7 ROR R14      		ROR RS1_10097:94D7 ROR R13      		ROR RS1_00098:94C7 ROR R12      		ADD RD0,FF0099:0D41 ADD R20,R1      	until FLAGS.1009A:F7D1 BRNE 0x0095      //	until --RD0;            	goto Store_RS1009B:CFE2 RJMP 0x007E                  //      // SLTI, SLTIU      //      DO_SLT:      	if I1.4 then goto Do_SLTIU009C:FD14 SBRC R17,4009D:C003 RJMP 0x00A1      	WREG := $80;	009E:E8F0 LDI R31,0x80      	RS1_3 := RS1_3 + WREG009F:0EFF ADD R15,R31      	RD3 := RD3 + WREG00A0:0F7F ADD R23,R31      Do_SLTIU:              SUB RS1_0, RD000A1:1AC4 SUB R12,R20              SBC RS1_1, RD100A2:0AD5 SBC R13,R21              SBC RS1_2, RD200A3:0AE6 SBC R14,R22              SBC RS1_3, RD300A4:0AF7 SBC R15,R23      asm      	brcs Store_100A5:F008 BRCS 0x00A7      end            	goto Store_000A6:CF68 RJMP 0x000F      Store_1:      	RD0 := 1;00A7:E041 LDI R20,0x01      	goto Store_RD_BYTE00A8:CF67 RJMP 0x0010                  // LOAD      // RS1 loaded, RD immed      I_00_0X1:      	//      	if not I0.6 then goto Do_Loads00A9:FF06 SBRS R16,600AA:C00F RJMP 0x00BA            // JALR      	ADD RS1_0, RD000AB:0EC4 ADD R12,R20      	ADC RS1_1, RD100AC:1ED5 ADC R13,R21            	//PC := PC+4      	PC.lo := PC.lo+400AD:E0F4 LDI R31,0x0400AE:0EAF ADD R10,R31      	ADC PC.hi, ZERO00AF:1CB0 ADC R11,R0            	RD0 := PC.lo00B0:2D4A MOV R20,R10      	RD1 := PC.hi00B1:2D5B MOV R21,R11            	AND RS1_0, $FE	// JALR TEST !00B2:EFFE LDI R31,0xFE00B3:22CF AND R12,R31      	      	PC.lo := RS1_000B4:2CAC MOV R10,R12      	PC.hi := RS1_100B5:2CBD MOV R11,R13            	WREG := 400B6:E0F4 LDI R31,0x04      	SUB PC.lo, WREG00B7:1AAF SUB R10,R31      	SBC PC.hi, ZERO00B8:08B0 SBC R11,R0            	// Store return PC      	goto Store_RD_WORD00B9:CF57 RJMP 0x0011                  Do_LOADS:      	Z.Lo := RS1_0;00BA:2DEC MOV R30,R12      	Z.Hi := RS1_1;00BB:2DFD MOV R31,R13      	Z.Lo := Z.lo + RD000BC:0FE4 ADD R30,R20      	ADC Z.Hi, RD100BD:1FF5 ADC R31,R21      // Load from memory      	RD0 := RAM[Z];00BE:8140 LD R20,Z               if I1.4 then goto I_LD_H // 00BF:FD14 SBRC R17,400C0:C014 RJMP 0x00D5              if I1.5 then goto I_LD_W // 00C1:FD15 SBRC R17,500C2:C00A RJMP 0x00CD      // LB, LBU      	if I1.6 then goto Store_RD_BYTE00C3:FD16 SBRC R17,600C4:CF4B RJMP 0x0010      	if not RD0.7 then goto Store_RD_BYTE00C5:FF47 SBRS R20,700C6:CF49 RJMP 0x0010      	RD1 := $FF00C7:EF5F LDI R21,0xFF      //	goto I_LH      I_LH:      // sign extend      	if not RD1.7 then goto Store_RD_WORD00C8:FF57 SBRS R21,700C9:CF47 RJMP 0x0011      	RD2 := $FF;00CA:EF6F LDI R22,0xFF      	RD3 := $FF;00CB:EF7F LDI R23,0xFF      	goto Store_RD00CC:CF46 RJMP 0x0013            I_LD_W:      	if Zlo.0 then MISALIGN_LD00CD:FDE0 SBRC R30,000CE:CF38 RJMP 0x0007      	if Zlo.1 then MISALIGN_LD00CF:FDE1 SBRC R30,100D0:CF36 RJMP 0x0007            	RD1 := RAM[Z+1]; 00D1:8151 LD R21,Z+1      	RD2 := RAM[Z+2]; 00D2:8162 LD R22,Z+2      	RD3 := RAM[Z+3];00D3:8173 LD R23,Z+3      	goto Store_RD	00D4:CF3E RJMP 0x0013      //            I_LD_H:      	if Zlo.0 then MISALIGN_LD00D5:FDE0 SBRC R30,000D6:CF30 RJMP 0x0007            	RD1 := RAM[Z+1]; 00D7:8151 LD R21,Z+1      	if not I1.6 then goto I_LH // 00D8:FF16 SBRS R17,600D9:CFEE RJMP 0x00C8      // LHU UNSIGNED              goto Store_RD_WORD	00DA:CF36 RJMP 0x0011            //       I_X1_XX0:            // SYSTEM also here !!                     // JALR ??            if not I0.6 then goto not_JALR00DB:FF06 SBRS R16,600DC:C04E RJMP 0x012B      //      if not I0.5 then goto not_JALR      I_11:            if     I0.4 then goto Do_SYS00DD:FD04 SBRC R16,400DE:C005 RJMP 0x00E4            if     I0.3 then goto not_JALR00DF:FD03 SBRC R16,300E0:C04A RJMP 0x012B            if not I0.2 then goto not_JALR00E1:FF02 SBRS R16,200E2:C048 RJMP 0x012B            goto I_IMMED00E3:CF60 RJMP 0x0044            //      //      //      Do_SYS:            #file 4      #line 1      ////////////////////////////////////      	Z.hi  := CRH00E4:EFF2 LDI R31,0xF2              Z.lo  := $10		 // mepc 	00E5:E1E0 LDI R30,0x10      	TEMP  := 0;00E6:E0C0 LDI R28,0x00      	      	// EBREAK/ECALL ?      	WREG := I100E7:2FF1 MOV R31,R17      	WREG := WREG and $7000E8:77F0 ANDI R31,0x70      	if WREG=0 then00E9:23FF AND R31,R3100EA:F4A9 BRNE 0x0100      		if not I3.4 then SYS_xxx0_xxxx_xxxx00EB:FF34 SBRS R19,400EC:C003 RJMP 0x00F0      SYS_xxxx_xxxx_xxxx: 		               		if I3.5 then do_exec  // MRET00ED:FD35 SBRC R19,500EE:C00E RJMP 0x00FD      		// WFI      		TEMP := $8000EF:E8C0 LDI R28,0x80            		      SYS_xxx0_xxxx_xxxx:      // ECALL/EBREAK      		RAM[Z] := PC.lo	         // mepc00F0:82A0 ST Z,R10      		RAM[Z+1] := PC.hi        // 00F1:82B1 ST Z+1,R11            		WREG := $03		 // ECALL/EBREAK00F2:E0F3 LDI R31,0x03      		if I2.4 then skip00F3:FF24 SBRS R18,4      			or WREG, $0800F4:60F8 ORI R31,0x08      		if temp=0 then skip00F5:23CC AND R28,R2800F6:F009 BREQ 0x00F8      			wreg := 7	 // MTIMER intterrupt	00F7:E0F7 LDI R31,0x07      		Z.lo   := $23;00F8:E2E3 LDI R30,0x23      		RAM[Z] := TEMP;		 // Interrupt flag00F9:83C0 ST Z,R28      go_mtvec_ecause:      	        Z.lo   := $20		 // mcause00FA:E2E0 LDI R30,0x20      		RAM[Z] := WREG	         // 00FB:83F0 ST Z,R31      go_mtvec:      	        Z.lo   := $50		 // mtvec00FC:E5E0 LDI R30,0x50      do_exec:      		PC.lo  := RAM[Z]         // 00FD:80A0 LD R10,Z       		PC.hi  := RAM[Z+1]         // 00FE:80B1 LD R11,Z+1            		goto MainStart00FF:CF2E RJMP 0x002E      	end       //////////////////////////////////////////////                  	Z.lo := I20100:2FE2 MOV R30,R18      	and Z.lo, $F00101:7FE0 ANDI R30,0xF0            //	if I3=$34 then            //	end            	if I3.7 then0102:FF37 SBRS R19,70103:C001 RJMP 0x0105      	     Z.lo := Z.lo or $40104:60E4 ORI R30,0x04      	end            	//      	// read CSR      	//      	RD0 := RAM[Z]; 0105:8140 LD R20,Z       	RD1 := RAM[Z+1];0106:8151 LD R21,Z+1      	RD2 := RAM[Z+2];0107:8162 LD R22,Z+2      	RD3 := RAM[Z+3]; 0108:8173 LD R23,Z+3      //      // CSR loaded      //      	if  not  I1.6 then goto csr_notimm0109:FF16 SBRS R17,6010A:C009 RJMP 0x0114      // todo get 5 bit immed value      	RS1_0 := i2; 010B:2EC2 MOV R12,R18      	RS1_0 := RS1_0 and $0F; 010C:E0FF LDI R31,0x0F010D:22CF AND R12,R31      	add RS1_0, RS1_0010E:0CCC ADD R12,R12      	if not I1.7 then skip; 010F:FD17 SBRC R17,7      	sub RS1_0,FF 0110:18C1 SUB R12,R1      	RS1_1 := 0;	0111:24DD EOR R13,R13      	RS1_2 := 0;0112:24EE EOR R14,R14      	RS1_3 := 0;0113:24FF EOR R15,R15      csr_notimm:      	if not I1.5 then goto CSR_WRITE0114:FF15 SBRS R17,50115:C010 RJMP 0x0126      	if     I1.4 then goto Do_CSRRC0116:FD14 SBRC R17,40117:C005 RJMP 0x011D      // Set Bits      	// Set Bits      	RS1_0 := RS1_0 or RD00118:2AC4 OR  R12,R20      	RS1_1 := RS1_1 or RD10119:2AD5 OR  R13,R21      	RS1_2 := RS1_2 or RD2011A:2AE6 OR  R14,R22      	RS1_3 := RS1_3 or RD3011B:2AF7 OR  R15,R23      	goto CSR_WRITE011C:C009 RJMP 0x0126      Do_CSRRC:      	WREG := $FF011D:EFFF LDI R31,0xFF      	RS1_0 := RS1_0 xor WREG	011E:26CF EOR R12,R31      	RS1_1 := RS1_1 xor WREG	011F:26DF EOR R13,R31      	RS1_2 := RS1_2 xor WREG	0120:26EF EOR R14,R31      	RS1_3 := RS1_3 xor WREG	0121:26FF EOR R15,R31            	RS1_0 := RS1_0 and RD00122:22C4 AND R12,R20      	RS1_1 := RS1_1 and RD10123:22D5 AND R13,R21      	RS1_2 := RS1_2 and RD20124:22E6 AND R14,R22      	RS1_3 := RS1_3 and RD30125:22F7 AND R15,R23      CSR_WRITE:      //      // Write back here      //       	// write CSR      	RAM[Z+3] := RS1_3; 0126:82F3 ST Z+3,R15      	RAM[Z+2] := RS1_2; 0127:82E2 ST Z+2,R14      	RAM[Z+1] := RS1_1; 0128:82D1 ST Z+1,R13      	RAM[Z] := RS1_00129:82C0 ST Z,R12      //////////////////////////////////            #file 1      #line 397            	goto Store_RD012A:CEE8 RJMP 0x0013            not_JALR:            //      if I0.6 then goto I_11_XX0 // branches      	if I0.6 then goto Load_RS2 // branches !012B:FD06 SBRC R16,6012C:C012 RJMP 0x013F            // STORE      I_01_XX0:      // RS1 is loaded            	if I0.4 then goto Load_RS2; //STORE012D:FD04 SBRC R16,4012E:C010 RJMP 0x013F      //      // RS1 is loaded      //      //I_01_1X0:            //	Goto Load_RS2            STORE:	        	RD0 := I1012F:2F41 MOV R20,R17      	add RD0,RD00130:0F44 ADD R20,R20      	and RD0,$1E0131:714E ANDI R20,0x1E      	if not I0.7 then skip; RD0 := RD0 or $01;0132:FD07 SBRC R16,70133:6041 ORI R20,0x01            	wreg := i30134:2FF3 MOV R31,R19      	swap wreg0135:95F2 SWAP R31      	and wreg,$E0;0136:7EF0 ANDI R31,0xE0      	or RD0, wreg0137:2B4F OR  R20,R31            	RD1 := I3;0138:2F53 MOV R21,R19      	swap RD10139:9552 SWAP R21      	and RD1, $07013A:7057 ANDI R21,0x07      	if not I3.7 then skip; RD1 := RD1 or $F8; // sign extend!013B:FD37 SBRC R19,7013C:6F58 ORI R21,0xF8            	RS1_0 := RS1_0 + RD0013D:0EC4 ADD R12,R20      	ADC RS1_1, RD1013E:1ED5 ADC R13,R21            // Load RS2      Load_RS2:      //            // xxxx_xxx4 3210_xxxx xxxx_xxxx xxxx_xxxx      // x432 10xx      //        Z.lo := I2      //	lsr Z.lo      //	lsr Z.lo      //        if not I3.0 then skip; Z.lo := Z.lo or $40;      //	Z.lo := Z.lo and $7C                    Z.lo := I2013F:2FE2 MOV R30,R18      	//lsr Z.lo      	lsr Z.lo0140:95E6 LSR R30              if not I3.0 then skip; Z.lo := Z.lo or $80;0141:FD30 SBRC R19,00142:68E0 ORI R30,0x80      	Z.lo := Z.lo and $F80143:7FE8 ANDI R30,0xF8            // Makes Dhrystone slower on single cycle RAM      //	if not FLAGS.1 then Load_RS2_RAM      //	RS2_0 := 0	      //	RS2_1 := 0	      //	RS2_2 := 0	      //	RS2_3 := 0	      //   	goto Load_RS2_Done            // TODO R0 ZERO !!      Load_RS2_RAM:      	Z.Hi := RRH; // Register save area0144:EFF1 LDI R31,0xF1      	RS2_0 := RAM[Z]; 0145:8180 LD R24,Z       	RS2_1 := RAM[Z+1];0146:8191 LD R25,Z+1      	RS2_2 := RAM[Z+2];0147:81A2 LD R26,Z+2      	RS2_3 := RAM[Z+3]; 0148:81B3 LD R27,Z+3      Load_RS2_Done:      // Branches?      //	if I0.6 then goto Do_Branch            	if not I0.6 then alustore0149:FF06 SBRS R16,6014A:C02A RJMP 0x0175            // branches      Do_Branch:      //      // Check condition      //      // signed?	      	if I1.5 then goto UNSIG014B:FD15 SBRC R17,5014C:C003 RJMP 0x0150      // signed trick      	wreg := $80014D:E8F0 LDI R31,0x80      	xor RS1_3, wreg014E:26FF EOR R15,R31      	xor RS2_3, wreg014F:27BF EOR R27,R31      UNSIG:	      	SUB RS1_0, RS2_00150:1AC8 SUB R12,R24      	SBC RS1_1, RS2_10151:0AD9 SBC R13,R25      	SBC RS1_2, RS2_20152:0AEA SBC R14,R26      	SBC RS1_3, RS2_30153:0AFB SBC R15,R27      	      	if not I1.6 then goto BNE_BEQ0154:FF16 SBRS R17,60155:C016 RJMP 0x016C      	if     I1.4 then goto is_BGE0156:FD14 SBRC R17,40157:C002 RJMP 0x015A      // BLT      asm      	brcs Take_Branch0158:F010 BRCS 0x015B      end	      	goto MainLoop0159:CEC5 RJMP 0x001F            // BGEU      is_BGE:      asm      	brcs main_l1;   //brcc Take_Branch015A:F0B8 BRCS 0x0172      end	      //	goto MainLoop            Take_Branch:      	add i1,i1015B:0F11 ADD R17,R17      	and i1, $1E // bits 4..1015C:711E ANDI R17,0x1E      	swap i3015D:9532 SWAP R19      	wreg := i3015E:2FF3 MOV R31,R19      	and wreg, $E0015F:7EF0 ANDI R31,0xE0      	or i1, wreg	// 7..10160:2B1F OR  R17,R31      	and i3,$0f0161:703F ANDI R19,0x0F      	if not i3.3 then skip0162:FD33 SBRC R19,3      	or i3,$10	// merge bit 120163:6130 ORI R19,0x10      	and i3,$170164:7137 ANDI R19,0x17      	if not i0.7 then skip0165:FD07 SBRC R16,7      	or i3,$08	// merge bit 110166:6038 ORI R19,0x08      	if not i3.4 then skip0167:FD34 SBRC R19,4      	or i3,$E0	// sign extend 16 bit0168:6E30 ORI R19,0xE0      	add PC.lo, i10169:0EA1 ADD R10,R17      	adc PC.hi, i3016A:1EB3 ADC R11,R19      	goto MainStart016B:CEC2 RJMP 0x002E            BNE_BEQ:      	or RS1_0, RS1_1016C:28CD OR  R12,R13      	or RS1_0, RS1_2016D:28CE OR  R12,R14      	or RS1_0, RS1_3016E:28CF OR  R12,R15      	if not I1.4 then goto is_BEQ	016F:FF14 SBRS R17,40170:C002 RJMP 0x0173      // BNE      asm      	brne Take_Branch0171:F749 BRNE 0x015B      end	      main_l1:      	goto MainLoop0172:CEAC RJMP 0x001F            is_BEQ:      asm      	breq Take_Branch0173:F339 BREQ 0x015B      end	      	goto MainLoop0174:CEAA RJMP 0x001F                  // Store or ALU ?      alustore:      	if not I0.4 then goto Do_Store0175:FF04 SBRS R16,40176:C011 RJMP 0x0188            	RD0 := RS2_00177:2F48 MOV R20,R24      	RD1 := RS2_10178:2F59 MOV R21,R25      	RD2 := RS2_20179:2F6A MOV R22,R26      	RD3 := RS2_3017A:2F7B MOV R23,R27      //      // check ALU       	if I1.6 then goto Do_XOR_AND // bit 14017B:FD16 SBRC R17,6017C:CF06 RJMP 0x0083      	if I1.5 then goto Do_SLT // bit 13017D:FD15 SBRC R17,5017E:CF1D RJMP 0x009C      	if I1.4 then goto Do_SLL // bit 12017F:FD14 SBRC R17,40180:CEF4 RJMP 0x0075            Do_AddSub:      	if not I3.6 then goto Do_ADDI	0181:FF36 SBRS R19,60182:CED8 RJMP 0x005B      // SUB OK              SUB RS1_0, RS2_00183:1AC8 SUB R12,R24              SBC RS1_1, RS2_10184:0AD9 SBC R13,R25              SBC RS1_2, RS2_20185:0AEA SBC R14,R26              SBC RS1_3, RS2_30186:0AFB SBC R15,R27            	goto Store_RS10187:CEF6 RJMP 0x007E                  Do_Store:      // store to RS1      	Z.Lo := RS1_00188:2DEC MOV R30,R12      	Z.Hi := RS1_10189:2DFD MOV R31,R13      //       	if I1.4 then goto I_SH_SW018A:FD14 SBRC R17,4018B:C013 RJMP 0x019F      	if I1.5 then goto I_SH_SW018C:FD15 SBRC R17,5018D:C011 RJMP 0x019F      // Store byte      I_SB:            	RAM[Z] := RS2_0; 018E:8380 ST Z,R24      #file 5      #line 1      // HAABBB G@@AAA      //      // Transmit Only UART implementation      //      //	RAM[Z] := RS2_0;       	// stupid way to exclude CPI      //        WREG := Z.hi      //	WREG := WREG-$C0      //	if not FLAGS.1 then              if not Zhi.7 then not_uart018F:FFF7 SBRS R31,70190:C00D RJMP 0x019E              if     Zhi.5 then not_uart0191:FDF5 SBRC R31,50192:C00B RJMP 0x019E      	      		temp := 10; // number of bits	0193:E0CA LDI R28,0x0A      		UART_TX = ZERO;	// Start bit0194:B800 OUT UART_TX,R0      		repeat      			wreg := UART_BAUDCONST; 0195:E8FF LDI R31,0x8F      			repeat       				ADD wreg,FF0196:0DF1 ADD R31,R1      			until FLAGS.10197:F7F1 BRNE 0x0196      //			until --wreg; // Bit delay 115200 50MHz      			UART_TX = RS2_0; // transmit bit0198:B980 OUT UART_TX,R24      			ROR RS2_0;0199:9587 ROR R24      			OR RS2_0, $80	// insert STOP bit019A:6880 ORI R24,0x80      			ADD temp,FF019B:0DC1 ADD R28,R1      		until FLAGS.1019C:F7C1 BRNE 0x0195      //		until --temp;      		Goto MainLoop019D:CE81 RJMP 0x001F      //	end;      not_uart:            //      //      //                  #file 1      #line 582            	goto MainLoop019E:CE80 RJMP 0x001F      //      I_SH_SW:      	if Zlo.0 then MISALIGN_ST019F:FDE0 SBRC R30,001A0:CE68 RJMP 0x0009      	if I1.4 then goto ST_LOW1601A1:FD14 SBRC R17,401A2:C004 RJMP 0x01A7      I_SW:      	if Zlo.1 then MISALIGN_ST01A3:FDE1 SBRC R30,101A4:CE64 RJMP 0x0009      	RAM[Z+3] := RS2_3; 01A5:83B3 ST Z+3,R27      	RAM[Z+2] := RS2_2; 01A6:83A2 ST Z+2,R26      ST_LOW16:      	RAM[Z] := RS2_0; 01A7:8380 ST Z,R24      	RAM[Z+1] := RS2_1; 01A8:8391 ST Z+1,R25      	goto MainLoop01A9:CE75 RJMP 0x001F            //      //      // LUI/AUIPC/JAL/JALR/FENCE      I_XX_XX1:             if I0.4 then goto I_XX_1X1  // -> AUIPC/LUI01AA:FD04 SBRC R16,401AB:C01D RJMP 0x01C9      // JAL/JALR/FENCE      I_XX_0X1:      	if not I0.5 then goto MainLoop // -> FENCE01AC:FF05 SBRS R16,501AD:CE71 RJMP 0x001F      I_X1_0X1:      // JAL/JALR      	if not I0.3 then goto LD_rs1  // JALR >>01AE:FF03 SBRS R16,301AF:CE88 RJMP 0x0038      // JAL            	swap I301B0:9532 SWAP R19      	AND I3, $F701B1:7F37 ANDI R19,0xF7      	if not I2.4 then skip01B2:FD24 SBRC R18,4      	OR I3, $08 // 7654 11 10 9 801B3:6038 ORI R19,0x08      	swap I201B4:9522 SWAP R18      	AND I2,$0E // xxxx 3 2 1 _01B5:702E ANDI R18,0x0E      	RS1_0 := I301B6:2EC3 MOV R12,R19      	RS1_0 := RS1_0 and $F001B7:EFF0 LDI R31,0xF001B8:22CF AND R12,R31      	RS1_0 := RS1_0 or I2 // 7..1 x01B9:2AC2 OR  R12,R18      	RS1_1 := I101BA:2ED1 MOV R13,R17      	RS1_1 := RS1_1 and $F0 // 15..1201BB:22DF AND R13,R31      	I3 := I3 and $0F01BC:703F ANDI R19,0x0F      	RS1_1 := RS1_1 or I301BD:2AD3 OR  R13,R19      	//       Store_RET:      	PC.lo := PC.lo+4	01BE:E0F4 LDI R31,0x0401BF:0EAF ADD R10,R31      	ADC PC.hi, ZERO01C0:1CB0 ADC R11,R0      		RD0 := PC.lo01C1:2D4A MOV R20,R10      		RD1 := PC.hi01C2:2D5B MOV R21,R11      	ADD PC.lo, RS1_001C3:0CAC ADD R10,R12      	ADC PC.hi, RS1_101C4:1CBD ADC R11,R13      		WREG := 801C5:E0F8 LDI R31,0x08      		SUB PC.lo, WREG01C6:1AAF SUB R10,R31      		SBC PC.hi, ZERO01C7:08B0 SBC R11,R0      	goto Store_RD_WORD01C8:CE48 RJMP 0x0011            // AUIPC/LUI      I_XX_1X1:      	// Load IMMED, clear lower bits      	RD3 := I3; // copy bits 31..24	01C9:2F73 MOV R23,R19      	RD2 := I2; // copy bits 23..1601CA:2F62 MOV R22,R18      	RD1 := I1; // copy bits 15..801CB:2F51 MOV R21,R17      	RD1 := RD1 and $F0; // clear bits 11..801CC:7F50 ANDI R21,0xF0      	RD0 := 0;  // clear bits 7..001CD:E040 LDI R20,0x00              if I0.5 then goto Store_RD01CE:FD05 SBRC R16,501CF:CE43 RJMP 0x0013            // AUIPC            	RD0 := PC.lo;01D0:2D4A MOV R20,R10      	RD1 := RD1 + PC.hi01D1:0D5B ADD R21,R11      	goto Store_RD01D2:CE40 RJMP 0x0013      //      //      //                  	until false;01D3:CE4B RJMP 0x001F      //      //      //                                                * SYMBOL TABLE ** LABELS *MISALIGN_LD                       0007  0MISALIGN_ST                       0009  0MISALING_LDST                     000A  0STORE_0                           000F  0STORE_RD_BYTE                     0010  0STORE_RD_WORD                     0011  0STORE_RD                          0013  0REPEAT@01                         001F  0MAINLOOP                          001F  0MTVEC_MTVAL                       0023  0MTVEC_MEPC                        0027  0MTVEC_ECAUSE                      002A  0NEXTPC                            002B  0MAINSTART                         002E  0LD_RS1                            0038  0I_0X_XX0                          0044  0I_XX_XX0                          0044  0I_IMMED                           0044  0IMM12_P                           0053  0DO_ADDI                           005B  0LOGIC                             0060  0DO_XOR                            0064  0OR_AND                            0069  0DO_OR                             006B  0DO_AND                            0070  0DO_SLL                            0075  0DO_SLLI                           0076  0REPEAT@02                         0078  0REPEAT@02@CONT                    007D  0REPEAT@02@BREAK                   007E  0STORE_RS1                         007E  0DO_XOR_AND                        0083  0DO_SR                             008A  0REPEAT@03                         008E  0REPEAT@03@CONT                    0093  0REPEAT@03@BREAK                   0094  0DO_SRLI                           0095  0REPEAT@04                         0095  0REPEAT@04@CONT                    009A  0REPEAT@04@BREAK                   009B  0DO_SLT                            009C  0DO_SLTIU                          00A1  0STORE_1                           00A7  0I_00_0X1                          00A9  0DO_LOADS                          00BA  0I_LH                              00C8  0I_LD_W                            00CD  0I_LD_H                            00D5  0I_X1_XX0                          00DB  0I_11                              00DD  0DO_SYS                            00E4  0SYS_XXXX_XXXX_XXXX                00ED  0SYS_XXX0_XXXX_XXXX                00F0  0GO_MTVEC_ECAUSE                   00FA  0GO_MTVEC                          00FC  0DO_EXEC                           00FD  0IF@001@ELSE                       0100  0IF@001@END                        0100  0IF@002@ELSE                       0105  0IF@002@END                        0105  0CSR_NOTIMM                        0114  0DO_CSRRC                          011D  0CSR_WRITE                         0126  0NOT_JALR                          012B  0I_01_XX0                          012D  0STORE                             012F  0LOAD_RS2                          013F  0LOAD_RS2_RAM                      0144  0LOAD_RS2_DONE                     0149  0DO_BRANCH                         014B  0UNSIG                             0150  0IS_BGE                            015A  0TAKE_BRANCH                       015B  0BNE_BEQ                           016C  0MAIN_L1                           0172  0IS_BEQ                            0173  0ALUSTORE                          0175  0DO_ADDSUB                         0181  0DO_STORE                          0188  0I_SB                              018E  0REPEAT@05                         0195  0REPEAT@06                         0196  0REPEAT@06@CONT                    0197  0REPEAT@06@BREAK                   0198  0REPEAT@05@CONT                    019C  0REPEAT@05@BREAK                   019D  0NOT_UART                          019E  0I_SH_SW                           019F  0I_SW                              01A3  0ST_LOW16                          01A7  0I_XX_XX1                          01AA  0I_XX_0X1                          01AC  0I_X1_0X1                          01AE  0STORE_RET                         01BE  0I_XX_1X1                          01C9  0REPEAT@01@CONT                    01D3  0REPEAT@01@BREAK                   01D4  0Program Memory used : 468 wordsInternal EEPROM used: 0 bytesErrors: 0